import 'dart:async';
import 'package:url_launcher/url_launcher.dart';
import 'package:permission_handler/permission_handler.dart';
import '../../models/contact.dart';
import '../../models/alert.dart';
import '../../utils/constants.dart';

class SmsService {
  static final SmsService _instance = SmsService._internal();
  factory SmsService() => _instance;
  SmsService._internal();

  final StreamController<bool> _smsSentController =
      StreamController<bool>.broadcast();
  Stream<bool> get smsSentStream => _smsSentController.stream;

  Future<bool> checkPermissions() async {
    try {
      final status = await Permission.sms.request();
      return status == PermissionStatus.granted;
    } catch (e) {
      print('Error checking SMS permissions: $e');
      return false;
    }
  }

  Future<bool> sendEmergencyAlert({
    required List<EmergencyContact> contacts,
    required Alert alert,
    String? customMessage,
    String? locationInfo,
  }) async {
    try {
      final hasPermission = await checkPermissions();
      if (!hasPermission) {
        print('SMS permissions not granted');
        return false;
      }

      final message = _buildEmergencyMessage(
        alert: alert,
        customMessage: customMessage,
        locationInfo: locationInfo,
      );

      bool allSent = true;
      for (final contact in contacts.where((c) => c.isEnabled)) {
        try {
          // Use URL launcher to send SMS
          final url = Uri.parse('sms:${contact.phoneNumber}?body=${Uri.encodeComponent(message)}');
          
          if (await canLaunchUrl(url)) {
            await launchUrl(url);
          } else {
            print('Could not launch SMS app for ${contact.name}');
            allSent = false;
          }
        } catch (e) {
          print('Error sending SMS to ${contact.name}: $e');
          allSent = false;
        }
      }

      _smsSentController.add(allSent);
      return allSent;
    } catch (e) {
      print('Error sending emergency SMS: $e');
      _smsSentController.add(false);
      return false;
    }
  }

  String _buildEmergencyMessage({
    required Alert alert,
    String? customMessage,
    String? locationInfo,
  }) {
    final buffer = StringBuffer();

    // Add alert prefix
    buffer.writeln('EMERGENCY ALERT');

    // Add alert type
    buffer.writeln('Type: ${_alertTypeToString(alert.type)}');

    // Add timestamp
    buffer.writeln('Time: ${alert.timestamp.toString().substring(0, 19)}');

    // Add location info if available
    if (locationInfo != null && locationInfo.isNotEmpty) {
      buffer.writeln(locationInfo);
    } else if (alert.latitude != null && alert.longitude != null) {
      buffer.writeln('Location: ${alert.latitude}, ${alert.longitude}');
      if (alert.address != null && alert.address!.isNotEmpty) {
        buffer.writeln('Address: ${alert.address}');
      }
    }

    // Add custom message if provided
    if (customMessage != null && customMessage.isNotEmpty) {
      buffer.writeln(customMessage);
    }

    // Add app signature
    buffer.writeln('Sent via Emergency Alert App');

    return buffer.toString();
  }

  String _alertTypeToString(AlertType type) {
    switch (type) {
      case AlertType.fall:
        return 'Fall Detected';
      case AlertType.impact:
        return 'Impact/Crash Detected';
      case AlertType.manual:
        return 'Manual Alert';
      case AlertType.inactivity:
        return 'Inactivity Alert';
      case AlertType.geo:
        return 'Geo-fence Alert';
      default:
        return 'Emergency';
    }
  }

  void dispose() {
    _smsSentController.close();
  }
}
